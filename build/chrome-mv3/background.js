var background=function(){"use strict";var P,C,U,B;function Q(o){return o==null||typeof o=="function"?{main:o}:o}const x=((C=(P=globalThis.browser)==null?void 0:P.runtime)==null?void 0:C.id)==null?globalThis.chrome:globalThis.browser;var W=Object.prototype.hasOwnProperty;function j(o,e){var n,i;if(o===e)return!0;if(o&&e&&(n=o.constructor)===e.constructor){if(n===Date)return o.getTime()===e.getTime();if(n===RegExp)return o.toString()===e.toString();if(n===Array){if((i=o.length)===e.length)for(;i--&&j(o[i],e[i]););return i===-1}if(!n||typeof o=="object"){i=0;for(n in o)if(W.call(o,n)&&++i&&!W.call(e,n)||!(n in e)||!j(o[n],e[n]))return!1;return Object.keys(e).length===i}}return o!==o&&e!==e}const G=new Error("request for lock canceled");var J=function(o,e,n,i){function d(u){return u instanceof n?u:new n(function(h){h(u)})}return new(n||(n=Promise))(function(u,h){function g(v){try{_(i.next(v))}catch(b){h(b)}}function M(v){try{_(i.throw(v))}catch(b){h(b)}}function _(v){v.done?u(v.value):d(v.value).then(g,M)}_((i=i.apply(o,e||[])).next())})};class Y{constructor(e,n=G){this._value=e,this._cancelError=n,this._queue=[],this._weightedWaiters=[]}acquire(e=1,n=0){if(e<=0)throw new Error(`invalid weight ${e}: must be positive`);return new Promise((i,d)=>{const u={resolve:i,reject:d,weight:e,priority:n},h=F(this._queue,g=>n<=g.priority);h===-1&&e<=this._value?this._dispatchItem(u):this._queue.splice(h+1,0,u)})}runExclusive(e){return J(this,arguments,void 0,function*(n,i=1,d=0){const[u,h]=yield this.acquire(i,d);try{return yield n(u)}finally{h()}})}waitForUnlock(e=1,n=0){if(e<=0)throw new Error(`invalid weight ${e}: must be positive`);return this._couldLockImmediately(e,n)?Promise.resolve():new Promise(i=>{this._weightedWaiters[e-1]||(this._weightedWaiters[e-1]=[]),z(this._weightedWaiters[e-1],{resolve:i,priority:n})})}isLocked(){return this._value<=0}getValue(){return this._value}setValue(e){this._value=e,this._dispatchQueue()}release(e=1){if(e<=0)throw new Error(`invalid weight ${e}: must be positive`);this._value+=e,this._dispatchQueue()}cancel(){this._queue.forEach(e=>e.reject(this._cancelError)),this._queue=[]}_dispatchQueue(){for(this._drainUnlockWaiters();this._queue.length>0&&this._queue[0].weight<=this._value;)this._dispatchItem(this._queue.shift()),this._drainUnlockWaiters()}_dispatchItem(e){const n=this._value;this._value-=e.weight,e.resolve([n,this._newReleaser(e.weight)])}_newReleaser(e){let n=!1;return()=>{n||(n=!0,this.release(e))}}_drainUnlockWaiters(){if(this._queue.length===0)for(let e=this._value;e>0;e--){const n=this._weightedWaiters[e-1];n&&(n.forEach(i=>i.resolve()),this._weightedWaiters[e-1]=[])}else{const e=this._queue[0].priority;for(let n=this._value;n>0;n--){const i=this._weightedWaiters[n-1];if(!i)continue;const d=i.findIndex(u=>u.priority<=e);(d===-1?i:i.splice(0,d)).forEach(u=>u.resolve())}}}_couldLockImmediately(e,n){return(this._queue.length===0||this._queue[0].priority<n)&&e<=this._value}}function z(o,e){const n=F(o,i=>e.priority<=i.priority);o.splice(n+1,0,e)}function F(o,e){for(let n=o.length-1;n>=0;n--)if(e(o[n]))return n;return-1}var H=function(o,e,n,i){function d(u){return u instanceof n?u:new n(function(h){h(u)})}return new(n||(n=Promise))(function(u,h){function g(v){try{_(i.next(v))}catch(b){h(b)}}function M(v){try{_(i.throw(v))}catch(b){h(b)}}function _(v){v.done?u(v.value):d(v.value).then(g,M)}_((i=i.apply(o,e||[])).next())})};class X{constructor(e){this._semaphore=new Y(1,e)}acquire(){return H(this,arguments,void 0,function*(e=0){const[,n]=yield this._semaphore.acquire(1,e);return n})}runExclusive(e,n=0){return this._semaphore.runExclusive(()=>e(),1,n)}isLocked(){return this._semaphore.isLocked()}waitForUnlock(e=0){return this._semaphore.waitForUnlock(1,e)}release(){this._semaphore.isLocked()&&this._semaphore.release()}cancel(){return this._semaphore.cancel()}}const k=((B=(U=globalThis.browser)==null?void 0:U.runtime)==null?void 0:B.id)==null?globalThis.chrome:globalThis.browser,T=Z();function Z(){const o={local:q("local"),session:q("session"),sync:q("sync"),managed:q("managed")},e=a=>{const r=o[a];if(r==null){const t=Object.keys(o).join(", ");throw Error(`Invalid area "${a}". Options: ${t}`)}return r},n=a=>{const r=a.indexOf(":"),t=a.substring(0,r),s=a.substring(r+1);if(s==null)throw Error(`Storage key should be in the form of "area:key", but received "${a}"`);return{driverArea:t,driverKey:s,driver:e(t)}},i=a=>a+"$",d=(a,r)=>{const t={...a};return Object.entries(r).forEach(([s,c])=>{c==null?delete t[s]:t[s]=c}),t},u=(a,r)=>a??r??null,h=a=>typeof a=="object"&&!Array.isArray(a)?a:{},g=async(a,r,t)=>{const s=await a.getItem(r);return u(s,(t==null?void 0:t.fallback)??(t==null?void 0:t.defaultValue))},M=async(a,r)=>{const t=i(r),s=await a.getItem(t);return h(s)},_=async(a,r,t)=>{await a.setItem(r,t??null)},v=async(a,r,t)=>{const s=i(r),c=h(await a.getItem(s));await a.setItem(s,d(c,t))},b=async(a,r,t)=>{if(await a.removeItem(r),t!=null&&t.removeMeta){const s=i(r);await a.removeItem(s)}},R=async(a,r,t)=>{const s=i(r);if(t==null)await a.removeItem(s);else{const c=h(await a.getItem(s));[t].flat().forEach(l=>delete c[l]),await a.setItem(s,c)}},S=(a,r,t)=>a.watch(r,t);return{getItem:async(a,r)=>{const{driver:t,driverKey:s}=n(a);return await g(t,s,r)},getItems:async a=>{const r=new Map,t=new Map,s=[];a.forEach(l=>{let w,m;typeof l=="string"?w=l:"getValue"in l?(w=l.key,m={fallback:l.fallback}):(w=l.key,m=l.options),s.push(w);const{driverArea:p,driverKey:y}=n(w),I=r.get(p)??[];r.set(p,I.concat(y)),t.set(w,m)});const c=new Map;return await Promise.all(Array.from(r.entries()).map(async([l,w])=>{(await o[l].getItems(w)).forEach(p=>{const y=`${l}:${p.key}`,I=t.get(y),f=u(p.value,(I==null?void 0:I.fallback)??(I==null?void 0:I.defaultValue));c.set(y,f)})})),s.map(l=>({key:l,value:c.get(l)}))},getMeta:async a=>{const{driver:r,driverKey:t}=n(a);return await M(r,t)},getMetas:async a=>{const r=a.map(c=>{const l=typeof c=="string"?c:c.key,{driverArea:w,driverKey:m}=n(l);return{key:l,driverArea:w,driverKey:m,driverMetaKey:i(m)}}),t=r.reduce((c,l)=>{var w;return c[w=l.driverArea]??(c[w]=[]),c[l.driverArea].push(l),c},{}),s={};return await Promise.all(Object.entries(t).map(async([c,l])=>{const w=await k.storage[c].get(l.map(m=>m.driverMetaKey));l.forEach(m=>{s[m.key]=w[m.driverMetaKey]??{}})})),r.map(c=>({key:c.key,meta:s[c.key]}))},setItem:async(a,r)=>{const{driver:t,driverKey:s}=n(a);await _(t,s,r)},setItems:async a=>{const r={};a.forEach(t=>{const{driverArea:s,driverKey:c}=n("key"in t?t.key:t.item.key);r[s]??(r[s]=[]),r[s].push({key:c,value:t.value})}),await Promise.all(Object.entries(r).map(async([t,s])=>{await e(t).setItems(s)}))},setMeta:async(a,r)=>{const{driver:t,driverKey:s}=n(a);await v(t,s,r)},setMetas:async a=>{const r={};a.forEach(t=>{const{driverArea:s,driverKey:c}=n("key"in t?t.key:t.item.key);r[s]??(r[s]=[]),r[s].push({key:c,properties:t.meta})}),await Promise.all(Object.entries(r).map(async([t,s])=>{const c=e(t),l=s.map(({key:y})=>i(y));console.log(t,l);const w=await c.getItems(l),m=Object.fromEntries(w.map(({key:y,value:I})=>[y,h(I)])),p=s.map(({key:y,properties:I})=>{const f=i(y);return{key:f,value:d(m[f]??{},I)}});await c.setItems(p)}))},removeItem:async(a,r)=>{const{driver:t,driverKey:s}=n(a);await b(t,s,r)},removeItems:async a=>{const r={};a.forEach(t=>{let s,c;typeof t=="string"?s=t:"getValue"in t?s=t.key:"item"in t?(s=t.item.key,c=t.options):(s=t.key,c=t.options);const{driverArea:l,driverKey:w}=n(s);r[l]??(r[l]=[]),r[l].push(w),c!=null&&c.removeMeta&&r[l].push(i(w))}),await Promise.all(Object.entries(r).map(async([t,s])=>{await e(t).removeItems(s)}))},clear:async a=>{await e(a).clear()},removeMeta:async(a,r)=>{const{driver:t,driverKey:s}=n(a);await R(t,s,r)},snapshot:async(a,r)=>{var c;const s=await e(a).snapshot();return(c=r==null?void 0:r.excludeKeys)==null||c.forEach(l=>{delete s[l],delete s[i(l)]}),s},restoreSnapshot:async(a,r)=>{await e(a).restoreSnapshot(r)},watch:(a,r)=>{const{driver:t,driverKey:s}=n(a);return S(t,s,r)},unwatch(){Object.values(o).forEach(a=>{a.unwatch()})},defineItem:(a,r)=>{const{driver:t,driverKey:s}=n(a),{version:c=1,migrations:l={}}=r??{};if(c<1)throw Error("Storage item version cannot be less than 1. Initial versions should be set to 1, not 0.");const w=async()=>{var N;const f=i(s),[{value:E},{value:V}]=await t.getItems([s,f]);if(E==null)return;const K=(V==null?void 0:V.v)??1;if(K>c)throw Error(`Version downgrade detected (v${K} -> v${c}) for "${a}"`);console.debug(`[@wxt-dev/storage] Running storage migration for ${a}: v${K} -> v${c}`);const re=Array.from({length:c-K},(L,D)=>K+D+1);let $=E;for(const L of re)try{$=await((N=l==null?void 0:l[L])==null?void 0:N.call(l,$))??$}catch(D){throw Error(`v${L} migration failed for "${a}"`,{cause:D})}await t.setItems([{key:s,value:$},{key:f,value:{...V,v:c}}]),console.debug(`[@wxt-dev/storage] Storage migration completed for ${a} v${c}`,{migratedValue:$})},m=(r==null?void 0:r.migrations)==null?Promise.resolve():w().catch(f=>{console.error(`[@wxt-dev/storage] Migration failed for ${a}`,f)}),p=new X,y=()=>(r==null?void 0:r.fallback)??(r==null?void 0:r.defaultValue)??null,I=()=>p.runExclusive(async()=>{const f=await t.getItem(s);if(f!=null||(r==null?void 0:r.init)==null)return f;const E=await r.init();return await t.setItem(s,E),E});return m.then(I),{key:a,get defaultValue(){return y()},get fallback(){return y()},getValue:async()=>(await m,r!=null&&r.init?await I():await g(t,s,r)),getMeta:async()=>(await m,await M(t,s)),setValue:async f=>(await m,await _(t,s,f)),setMeta:async f=>(await m,await v(t,s,f)),removeValue:async f=>(await m,await b(t,s,f)),removeMeta:async f=>(await m,await R(t,s,f)),watch:f=>S(t,s,(E,V)=>f(E??y(),V??y())),migrate:w}}}}function q(o){const e=()=>{if(k.runtime==null)throw Error(["'wxt/storage' must be loaded in a web extension environment",`
 - If thrown during a build, see https://github.com/wxt-dev/wxt/issues/371`,` - If thrown during tests, mock 'wxt/browser' correctly. See https://wxt.dev/guide/go-further/testing.html
`].join(`
`));if(k.storage==null)throw Error("You must add the 'storage' permission to your manifest to use 'wxt/storage'");const i=k.storage[o];if(i==null)throw Error(`"browser.storage.${o}" is undefined`);return i},n=new Set;return{getItem:async i=>(await e().get(i))[i],getItems:async i=>{const d=await e().get(i);return i.map(u=>({key:u,value:d[u]??null}))},setItem:async(i,d)=>{d==null?await e().remove(i):await e().set({[i]:d})},setItems:async i=>{const d=i.reduce((u,{key:h,value:g})=>(u[h]=g,u),{});await e().set(d)},removeItem:async i=>{await e().remove(i)},removeItems:async i=>{await e().remove(i)},clear:async()=>{await e().clear()},snapshot:async()=>await e().get(),restoreSnapshot:async i=>{await e().set(i)},watch(i,d){const u=h=>{const g=h[i];g!=null&&(j(g.newValue,g.oldValue)||d(g.newValue??null,g.oldValue??null))};return e().onChanged.addListener(u),n.add(u),()=>{e().onChanged.removeListener(u),n.delete(u)}},unwatch(){n.forEach(i=>{e().onChanged.removeListener(i)}),n.clear()}}}const ee=Q(async()=>{x.alarms.create({periodInMinutes:5}),x.alarms.onAlarm.addListener(async()=>{const o=await(await fetch("https://www.youtube.com/@KAN11/videos")).text(),e=JSON.parse(o.match(/ytInitialData\s*=\s*({.+?})\s*;/)[1]);for(let n=0;n<e.contents.twoColumnBrowseResultsRenderer.tabs[1].tabRenderer.content.richGridRenderer.contents.length;n++){const{videoId:i,title:d}=e.contents.twoColumnBrowseResultsRenderer.tabs[1].tabRenderer.content.richGridRenderer.contents[n].richItemRenderer.content.videoRenderer,{text:u}=d.runs[0];if(!u.includes("מהצד השני"))continue;const h=u.match(/\d+\.\d+\.\d{4}/)[0],[g,M,_]=h.split("."),v=new Date(_,M-1,g),b=new Date,R=v.getDate()===b.getDate(),S=await T.getItem("local:lastVideoId");R?(await T.setItem("local:lastVideoId",i),await x.action.setBadgeText({text:"New Video"})):S&&await x.action.setBadgeText({text:"Old Video"})}}),x.action.onClicked.addListener(async()=>{const o=await T.getItem("local:lastVideoId");o&&(await x.tabs.create({url:`https://www.youtube.com/watch?v=${o}`}),await T.removeItem("local:lastVideoId"),await x.action.setBadgeText({text:""}))})});function ne(){}function O(o,...e){}const te={debug:(...o)=>O(console.debug,...o),log:(...o)=>O(console.log,...o),warn:(...o)=>O(console.warn,...o),error:(...o)=>O(console.error,...o)};let A;try{A=ee.main(),A instanceof Promise&&console.warn("The background's main() function return a promise, but it must be synchronous")}catch(o){throw te.error("The background crashed on startup!"),o}return A}();
background;
